{
  "language": "Solidity",
  "sources": {
    "@venusprotocol/solidity-utilities/contracts/constants.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\nuint256 constant EXP_SCALE = 1e18;\n\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\nuint256 constant MANTISSA_ONE = EXP_SCALE;\n\n/// @dev The approximate number of seconds per year\nuint256 constant SECONDS_PER_YEAR = 31_536_000;\n"
    },
    "@venusprotocol/solidity-utilities/contracts/validators.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\nerror ZeroAddressNotAllowed();\n\n/// @notice Thrown if the supplied value is 0 where it is not allowed\nerror ZeroValueNotAllowed();\n\n/// @notice Checks if the provided address is nonzero, reverts otherwise\n/// @param address_ Address to check\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\nfunction ensureNonzeroAddress(address address_) pure {\n    if (address_ == address(0)) {\n        revert ZeroAddressNotAllowed();\n    }\n}\n\n/// @notice Checks if the provided value is nonzero, reverts otherwise\n/// @param value_ Value to check\n/// @custom:error ZeroValueNotAllowed is thrown if the provided value is 0\nfunction ensureNonzeroValue(uint256 value_) pure {\n    if (value_ == 0) {\n        revert ZeroValueNotAllowed();\n    }\n}\n"
    },
    "contracts/interfaces/IAnkrBNB.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\ninterface IAnkrBNB {\n    function sharesToBonds(uint256 amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPStakePool.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\ninterface IPStakePool {\n    struct Data {\n        uint256 totalWei;\n        uint256 poolTokenSupply;\n    }\n\n    /**\n     * @dev The current exchange rate for converting stkBNB to BNB.\n     */\n    function exchangeRate() external view returns (Data memory);\n}\n"
    },
    "contracts/interfaces/IStaderStakeManager.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\ninterface IStaderStakerManager {\n    function convertBnbXToBnb(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISynclubStakeManager.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\ninterface ISynclubStakerManager {\n    function convertSnBnbToBnb(uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IWBETH.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\ninterface IWBETH {\n    function exchangeRate() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\ninterface OracleInterface {\n    function getPrice(address asset) external view returns (uint256);\n}\n\ninterface ResilientOracleInterface is OracleInterface {\n    function updatePrice(address vToken) external;\n\n    function updateAssetPrice(address asset) external;\n\n    function getUnderlyingPrice(address vToken) external view returns (uint256);\n}\n\ninterface TwapInterface is OracleInterface {\n    function updateTwap(address asset) external returns (uint256);\n}\n\ninterface BoundValidatorInterface {\n    function validatePriceWithAnchorPrice(\n        address asset,\n        uint256 reporterPrice,\n        uint256 anchorPrice\n    ) external view returns (bool);\n}\n"
    },
    "contracts/oracles/AnkrBNBOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { OracleInterface } from \"../interfaces/OracleInterface.sol\";\nimport { IAnkrBNB } from \"../interfaces/IAnkrBNB.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { EXP_SCALE } from \"@venusprotocol/solidity-utilities/contracts/constants.sol\";\n\n/**\n * @title AnkrBNBOracle\n * @author Venus\n * @notice This oracle fetches the price of ankrBNB asset\n */\ncontract AnkrBNBOracle is OracleInterface {\n    /// @notice Address of ankrBNB\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable ankrBNB;\n\n    /// @notice Address of Resilient Oracle\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    OracleInterface public immutable RESILIENT_ORACLE;\n\n    /// @notice Set this as asset address for native token on each chain.\n    address public constant NATIVE_TOKEN_ADDR = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    /// @notice Constructor for the implementation contract.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address _ankrBNB, address resilientOracleAddress) {\n        ensureNonzeroAddress(_ankrBNB);\n        ensureNonzeroAddress(resilientOracleAddress);\n        ankrBNB = _ankrBNB;\n        RESILIENT_ORACLE = OracleInterface(resilientOracleAddress);\n    }\n\n    /**\n     * @notice Gets the price of ankrBNB asset\n     * @param asset Address of ankrBNB\n     * @return price Price in USD scaled by 1e18\n     */\n    function getPrice(address asset) public view returns (uint256) {\n        if (asset != ankrBNB) revert(\"wrong ankrBNB address\");\n\n        // get BNB amount for 1 ankrBNB scaled by 1e18\n        uint256 BNBAmount = IAnkrBNB(ankrBNB).sharesToBonds(1 ether);\n\n        // price is scaled 1e18 (oracle returns 36 - asset decimal scale)\n        uint256 bnbUSDPrice = RESILIENT_ORACLE.getPrice(NATIVE_TOKEN_ADDR);\n\n        // ETHAmount (for 1 ankrBNB) * ethUSDPrice / 1e18\n        return (BNBAmount * bnbUSDPrice) / EXP_SCALE;\n    }\n}\n"
    },
    "contracts/oracles/BNBxOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { OracleInterface } from \"../interfaces/OracleInterface.sol\";\nimport { IStaderStakerManager } from \"../interfaces/IStaderStakeManager.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { EXP_SCALE } from \"@venusprotocol/solidity-utilities/contracts/constants.sol\";\n\n/**\n * @title BNBxOracle\n * @author Venus\n * @notice This oracle fetches the price of BNBx asset\n */\ncontract BNBxOracle is OracleInterface {\n    /// @notice Address of StakeManager\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IStaderStakerManager public immutable STAKE_MANAGER;\n\n    /// @notice Address of BNBx\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable BNBx;\n\n    /// @notice Address of Resilient Oracle\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    OracleInterface public immutable RESILIENT_ORACLE;\n\n    /// @notice Set this as asset address for native token on each chain.\n    address public constant NATIVE_TOKEN_ADDR = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    /// @notice Constructor for the implementation contract.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address stakeManager, address bnbx, address resilientOracleAddress) {\n        ensureNonzeroAddress(stakeManager);\n        ensureNonzeroAddress(bnbx);\n        ensureNonzeroAddress(resilientOracleAddress);\n        STAKE_MANAGER = IStaderStakerManager(stakeManager);\n        BNBx = bnbx;\n        RESILIENT_ORACLE = OracleInterface(resilientOracleAddress);\n    }\n\n    /**\n     * @notice Gets the price of BNBx asset\n     * @param asset Address of BNBx\n     * @return price Price in USD scaled by 1e18\n     */\n    function getPrice(address asset) public view returns (uint256) {\n        if (asset != BNBx) revert(\"wrong BNBx address\");\n\n        // get BNB amount for 1 BNBx scaled by 1e18\n        uint256 BNBAmount = STAKE_MANAGER.convertBnbXToBnb(1 ether);\n\n        // price is scaled 1e18 (oracle returns 36 - asset decimal scale)\n        uint256 bnbUSDPrice = RESILIENT_ORACLE.getPrice(NATIVE_TOKEN_ADDR);\n\n        // BNBAmount (for 1 BNBx) * bnbUSDPrice / 1e18\n        return (BNBAmount * bnbUSDPrice) / EXP_SCALE;\n    }\n}\n"
    },
    "contracts/oracles/SlisBNBOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { OracleInterface } from \"../interfaces/OracleInterface.sol\";\nimport { ISynclubStakerManager } from \"../interfaces/ISynclubStakeManager.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { EXP_SCALE } from \"@venusprotocol/solidity-utilities/contracts/constants.sol\";\n\n/**\n * @title SlisBNBOracle\n * @author Venus\n * @notice This oracle fetches the price of slisBNB asset\n */\ncontract SlisBNBOracle is OracleInterface {\n    /// @notice Address of StakeManager\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    ISynclubStakerManager public immutable STAKE_MANAGER;\n\n    /// @notice Address of slisBNB\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable slisBNB;\n\n    /// @notice Address of Resilient Oracle\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    OracleInterface public immutable RESILIENT_ORACLE;\n\n    /// @notice Set this as asset address for native token on each chain.\n    address public constant NATIVE_TOKEN_ADDR = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    /// @notice Constructor for the implementation contract.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address stakeManager, address _slisBNB, address resilientOracleAddress) {\n        ensureNonzeroAddress(stakeManager);\n        ensureNonzeroAddress(_slisBNB);\n        ensureNonzeroAddress(resilientOracleAddress);\n        STAKE_MANAGER = ISynclubStakerManager(stakeManager);\n        slisBNB = _slisBNB;\n        RESILIENT_ORACLE = OracleInterface(resilientOracleAddress);\n    }\n\n    /**\n     * @notice Gets the price of slisBNB asset\n     * @param asset Address of slisBNB\n     * @return price Price in USD scaled by 1e18\n     */\n    function getPrice(address asset) public view returns (uint256) {\n        if (asset != slisBNB) revert(\"wrong slisBNB address\");\n\n        // get BNB amount for 1 slisBNB scaled by 1e18\n        uint256 BNBAmount = STAKE_MANAGER.convertSnBnbToBnb(1 ether);\n\n        // price is scaled 1e18 (oracle returns 36 - asset decimal scale)\n        uint256 bnbUSDPrice = RESILIENT_ORACLE.getPrice(NATIVE_TOKEN_ADDR);\n\n        // BNBAmount (for 1 slisBNB) * bnbUSDPrice / 1e18\n        return (BNBAmount * bnbUSDPrice) / EXP_SCALE;\n    }\n}\n"
    },
    "contracts/oracles/StkBNBOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { OracleInterface } from \"../interfaces/OracleInterface.sol\";\nimport { IPStakePool } from \"../interfaces/IPStakePool.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { EXP_SCALE } from \"@venusprotocol/solidity-utilities/contracts/constants.sol\";\n\n/**\n * @title StkBNBOracle\n * @author Venus\n * @notice This oracle fetches the price of stkBNB asset\n */\ncontract StkBNBOracle is OracleInterface {\n    /// @notice Address of StakePool\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    IPStakePool public immutable STAKE_POOL;\n\n    /// @notice Address of stkBNB\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable stkBNB;\n\n    /// @notice Address of Resilient Oracle\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    OracleInterface public immutable RESILIENT_ORACLE;\n\n    /// @notice Set this as asset address for native token on each chain.\n    address public constant NATIVE_TOKEN_ADDR = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n    /// @notice Constructor for the implementation contract.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address stakePool, address _stkBNB, address resilientOracleAddress) {\n        ensureNonzeroAddress(stakePool);\n        ensureNonzeroAddress(_stkBNB);\n        ensureNonzeroAddress(resilientOracleAddress);\n        STAKE_POOL = IPStakePool(stakePool);\n        stkBNB = _stkBNB;\n        RESILIENT_ORACLE = OracleInterface(resilientOracleAddress);\n    }\n\n    /**\n     * @notice Gets the price of stkBNB asset\n     * @param asset Address of stkBNB\n     * @return price Price in USD scaled by 1e18\n     */\n    function getPrice(address asset) public view returns (uint256) {\n        if (asset != stkBNB) revert(\"wrong stkBNB address\");\n\n        // get BNB amount for 1 stkBNB scaled by 1e18\n        IPStakePool.Data memory exchangeRateData = STAKE_POOL.exchangeRate();\n        uint256 BNBAmount = (exchangeRateData.totalWei * EXP_SCALE) / exchangeRateData.poolTokenSupply;\n\n        // price is scaled 1e18 (oracle returns 36 - asset decimal scale)\n        uint256 bnbUSDPrice = RESILIENT_ORACLE.getPrice(NATIVE_TOKEN_ADDR);\n\n        // BNBAmount (for 1 stkBNB) * bnbUSDPrice / 1e18\n        return (BNBAmount * bnbUSDPrice) / EXP_SCALE;\n    }\n}\n"
    },
    "contracts/oracles/WBETHOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.13;\n\nimport { OracleInterface } from \"../interfaces/OracleInterface.sol\";\nimport { IWBETH } from \"../interfaces/IWBETH.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { EXP_SCALE } from \"@venusprotocol/solidity-utilities/contracts/constants.sol\";\n\n/**\n * @title WBETHOracle\n * @author Venus\n * @notice This oracle fetches the price of wBETH asset\n */\ncontract WBETHOracle is OracleInterface {\n    /// @notice Address of wBETH\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable wBETH;\n\n    /// @notice Address of Resilient Oracle\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    OracleInterface public immutable RESILIENT_ORACLE;\n\n    /// @notice Address of ETH\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    address public immutable ETH;\n\n    /// @notice Constructor for the implementation contract.\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address wbeth, address eth, address resilientOracleAddress) {\n        ensureNonzeroAddress(wbeth);\n        ensureNonzeroAddress(resilientOracleAddress);\n        ensureNonzeroAddress(eth);\n        wBETH = wbeth;\n        ETH = eth;\n        RESILIENT_ORACLE = OracleInterface(resilientOracleAddress);\n    }\n\n    /**\n     * @notice Gets the price of wBETH asset\n     * @param asset Address of wBETH\n     * @return price Price in USD scaled by 1e18\n     */\n    function getPrice(address asset) public view returns (uint256) {\n        if (asset != wBETH) revert(\"wrong wBETH address\");\n\n        // get ETH amount for 1 wBETH scaled by 1e18\n        uint256 ETHAmount = IWBETH(wBETH).exchangeRate();\n\n        // price is scaled 1e18 (oracle returns 36 - asset decimal scale)\n        uint256 ethUSDPrice = RESILIENT_ORACLE.getPrice(ETH);\n\n        // ETHAmount (for 1 wBETH) * ethUSDPrice / 1e18\n        return (ETHAmount * ethUSDPrice) / EXP_SCALE;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": true
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
